<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>WebXR Mini City – Starter</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html, body { margin:0; height:100%; background:#111; overflow:hidden; }
    #info {
      position: fixed; top: 8px; left: 8px; color: #eee; font: 14px/1.4 system-ui, sans-serif;
      background: rgba(0,0,0,.4); padding: 8px 10px; border-radius: 8px;
    }
    a { color:#8cf; text-decoration:none }
  </style>
</head>
<body>
  <div id="info">Mini City • Left stick: move/strafe • Right stick: turn • Desktop: WASD + QE • NARF!</div>
  <script type="module">
  import * as THREE from 'https://unpkg.com/three@0.159.0/build/three.module.js';
  import { VRButton } from 'https://unpkg.com/three@0.159.0/examples/jsm/webxr/VRButton.js';

  // --- basics -------------------------------------------------------
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x99bbff);
  scene.fog = new THREE.Fog(0x99bbff, 80, 300);

  const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1000);

  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(devicePixelRatio);
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);
  document.body.appendChild(VRButton.createButton(renderer));

  // Player dolly so we can move the XR camera around
  const dolly = new THREE.Object3D();
  dolly.position.set(0, 0, 0);
  scene.add(dolly);
  dolly.add(camera);

  // Lights
  const hemi = new THREE.HemisphereLight(0xffffff, 0x334455, 0.9);
  scene.add(hemi);
  const sun = new THREE.DirectionalLight(0xffffff, 0.8);
  sun.position.set(1, 2, 0.5).multiplyScalar(200);
  sun.castShadow = false;
  scene.add(sun);

  // --- city params --------------------------------------------------
  const BLOCK_SIZE = 40;      // size of a city block
  const ROAD_WIDTH = 8;       // width of roads
  const GRID_HALF = 3;        // blocks in each direction (total = (2*GRID_HALF+1)^2)
  const CITY_EXTENT = (BLOCK_SIZE + ROAD_WIDTH) * GRID_HALF + BLOCK_SIZE * 0.5;

  // Ground base
  {
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(2000, 2000),
      new THREE.MeshPhongMaterial({ color: 0x99d18f }) // grass
    );
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);
  }

  // --- roads (simple grid) -----------------------------------------
  const roadMat = new THREE.MeshPhongMaterial({ color: 0x333333 });
  function makeRoad(w, h) {
    const m = new THREE.Mesh(new THREE.PlaneGeometry(w, h), roadMat);
    m.rotation.x = -Math.PI/2;
    m.receiveShadow = true;
    return m;
  }

  // Build vertical and horizontal roads spanning the city
  for (let i = -GRID_HALF; i <= GRID_HALF; i++) {
    const offset = i * (BLOCK_SIZE + ROAD_WIDTH);
    // Z (north-south) road strip across X
    const zRoad = makeRoad( (GRID_HALF*2+1)*(BLOCK_SIZE+ROAD_WIDTH)+BLOCK_SIZE, ROAD_WIDTH );
    zRoad.position.set(0, 0.001, offset);
    scene.add(zRoad);

    // X (east-west) road strip across Z
    const xRoad = makeRoad( ROAD_WIDTH, (GRID_HALF*2+1)*(BLOCK_SIZE+ROAD_WIDTH)+BLOCK_SIZE );
    xRoad.position.set(offset, 0.001, 0);
    scene.add(xRoad);
  }

  // Lane lines: thin white planes down the center of each road
  const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
  for (let i = -GRID_HALF; i <= GRID_HALF; i++) {
    const offset = i * (BLOCK_SIZE + ROAD_WIDTH);
    const dashLen = 2, gapLen = 2;
    const totalLen = (GRID_HALF*2+1)*(BLOCK_SIZE+ROAD_WIDTH)+BLOCK_SIZE;
    let z = -totalLen/2;
    while (z < totalLen/2) {
      const seg = new THREE.Mesh(new THREE.PlaneGeometry(0.3, dashLen), lineMat);
      seg.rotation.x = -Math.PI/2;
      seg.position.set(offset, 0.003, z + dashLen/2);
      scene.add(seg);
      z += dashLen + gapLen;
    }

    let x = -totalLen/2;
    while (x < totalLen/2) {
      const seg = new THREE.Mesh(new THREE.PlaneGeometry(dashLen, 0.3), lineMat);
      seg.rotation.x = -Math.PI/2;
      seg.position.set(x + dashLen/2, 0.003, offset);
      scene.add(seg);
      x += dashLen + gapLen;
    }
  }

  // --- buildings (instanced for perf) -------------------------------
  const buildingGeom = new THREE.BoxGeometry(1, 1, 1);
  const buildingMat = new THREE.MeshLambertMaterial({ color: 0xcccccc });
  const buildingCount = 800;
  const buildings = new THREE.InstancedMesh(buildingGeom, buildingMat, buildingCount);
  scene.add(buildings);

  // --- trees (instanced) --------------------------------------------
  const trunk = new THREE.CylinderGeometry(0.2, 0.2, 2, 6);
  const leaves = new THREE.ConeGeometry(1.2, 2.5, 8);
  const treeMatTrunk = new THREE.MeshLambertMaterial({ color: 0x6b4f2a });
  const treeMatLeaves = new THREE.MeshLambertMaterial({ color: 0x2e8b57 });
  const treeTrunks = new THREE.InstancedMesh(trunk, treeMatTrunk, 300);
  const treeCrowns = new THREE.InstancedMesh(leaves, treeMatLeaves, 300);
  scene.add(treeTrunks, treeCrowns);

  // Scatter buildings & trees inside blocks (avoid roads)
  {
    const tmp = new THREE.Matrix4();
    const up = new THREE.Vector3(0,1,0);
    let b = 0, t = 0;

    function inRoad(x, z) {
      // near any road line?
      for (let i = -GRID_HALF; i <= GRID_HALF; i++) {
        const r = i*(BLOCK_SIZE+ROAD_WIDTH);
        if (Math.abs(z - r) < ROAD_WIDTH*0.5+1) return true;
        if (Math.abs(x - r) < ROAD_WIDTH*0.5+1) return true;
      }
      return false;
    }

    // Buildings
    for (let i = 0; i < buildingCount; i++) {
      const x = (Math.random()*2-1) * CITY_EXTENT;
      const z = (Math.random()*2-1) * CITY_EXTENT;
      if (inRoad(x,z)) { i--; continue; }

      const w = 4 + Math.random()*8;
      const d = 4 + Math.random()*8;
      const h = 6 + Math.random()*50;

      const m = new THREE.Matrix4()
        .makeScale(w, h, d)
        .premultiply(new THREE.Matrix4().makeTranslation(0, 0.5, 0));
      tmp.identity()
        .makeRotationY(Math.random()*Math.PI*2)
        .setPosition(x, 0, z)
        .multiply(m);
      buildings.setMatrixAt(b++, tmp);
    }
    buildings.count = b;
    buildings.instanceMatrix.needsUpdate = true;

    // Trees
    for (let i = 0; i < 300; i++) {
      const x = (Math.random()*2-1) * CITY_EXTENT;
      const z = (Math.random()*2-1) * CITY_EXTENT;
      if (inRoad(x,z)) { i--; continue; }

      const trunkH = 1.8 + Math.random()*0.8;
      const crownH = 2.0 + Math.random()*1.5;
      const m1 = new THREE.Matrix4()
        .makeScale(1, trunkH/2, 1)
        .premultiply(new THREE.Matrix4().makeTranslation(0, trunkH/2, 0));
      tmp.identity().setPosition(x, 0, z).multiply(m1);
      treeTrunks.setMatrixAt(t, tmp);

      const m2 = new THREE.Matrix4()
        .makeScale(1, crownH/2, 1)
        .premultiply(new THREE.Matrix4().makeTranslation(0, trunkH + crownH/2 - 0.3, 0));
      tmp.identity().setPosition(x, 0, z).multiply(m2);
      treeCrowns.setMatrixAt(t, tmp);

      t++;
    }
    treeTrunks.count = t; treeCrowns.count = t;
    treeTrunks.instanceMatrix.needsUpdate = true;
    treeCrowns.instanceMatrix.needsUpdate = true;
  }

  // --- billboards with goofy messages -------------------------------
  const messages = [
    "WELCOME TO NAZUGRIT CITY — BOAR CROSSING AHEAD",
    "HUNGRY? TOO BAD. THIS IS A SIGN, NOT A RESTAURANT.",
    "TRY OUR INVISIBLE COFFEE — 0 CALORIES, 0 FLAVOR",
    "WANTED: TREE HUGGER. MUST LOVE SPLINTERS.",
    "SPEED LIMIT: YES",
    "NOW HIRING: PROFESSIONAL BUTTON PRESSER",
    "THIS BILLBOARD LEFT BLANK ON PURPOSE. NARF!"
  ];

  function makeBillboardTexture(text) {
    const w = 512, h = 256;
    const c = document.createElement('canvas'); c.width = w; c.height = h;
    const ctx = c.getContext('2d');
    ctx.fillStyle = '#222'; ctx.fillRect(0,0,w,h);
    ctx.fillStyle = '#0ff';
    ctx.font = 'bold 36px system-ui, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    wrapText(ctx, text, w/2, h/2, w-40, 42);
    const tex = new THREE.CanvasTexture(c);
    tex.anisotropy = renderer.capabilities.getMaxAnisotropy?.() ?? 1;
    return tex;
  }
  function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
    const words = text.split(' ');
    let line = '', lines = [];
    for (let n=0; n<words.length; n++) {
      let test = line + words[n] + ' ';
      if (ctx.measureText(test).width > maxWidth && n>0) {
        lines.push(line); line = words[n] + ' ';
      } else line = test;
    }
    lines.push(line);
    const startY = y - ((lines.length-1) * lineHeight)/2;
    lines.forEach((ln, i) => ctx.fillText(ln.trim(), x, startY + i*lineHeight));
  }

  const billboardGeom = new THREE.PlaneGeometry(10, 5);
  const postGeom = new THREE.CylinderGeometry(0.15, 0.15, 6, 6);
  function addBillboard(x, z, text) {
    const tex = makeBillboardTexture(text);
    const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
    const board = new THREE.Mesh(billboardGeom, mat);
    board.position.set(x, 4, z);
    board.lookAt(0,4,0);

    const post = new THREE.Mesh(postGeom, new THREE.MeshLambertMaterial({ color: 0x555555 }));
    post.position.set(x, 3, z);
    scene.add(post, board);
    return { board, tex };
  }

  const billboards = [];
  for (let i = -GRID_HALF; i <= GRID_HALF; i++) {
    const x = i*(BLOCK_SIZE+ROAD_WIDTH) + (BLOCK_SIZE/2) * (i%2===0?1:-1);
    const z = (i%2===0?1:-1) * (BLOCK_SIZE+ROAD_WIDTH) * GRID_HALF;
    billboards.push(addBillboard(x, z, messages[(i+messages.length)%messages.length]));
  }
  // Rotate billboard messages every ~10 seconds
  let msgTick = 0;
  function rotateMessages(dt) {
    msgTick += dt;
    if (msgTick > 10) {
      msgTick = 0;
      for (const b of billboards) {
        const text = messages[Math.floor(Math.random()*messages.length)];
        b.tex.dispose();
        b.board.material.map = makeBillboardTexture(text);
        b.board.material.needsUpdate = true;
      }
    }
  }

  // --- cars that loop roads -----------------------------------------
  const carGeom = new THREE.BoxGeometry(2, 1, 4);
  const carMat = new THREE.MeshLambertMaterial({ color: 0xff5533 });
  const cars = [];
  const lanes = [];
  for (let i = -GRID_HALF; i <= GRID_HALF; i++) {
    lanes.push({ axis:'z', pos: i*(BLOCK_SIZE+ROAD_WIDTH) + ROAD_WIDTH*0.25, dir: 1 });
    lanes.push({ axis:'z', pos: i*(BLOCK_SIZE+ROAD_WIDTH) - ROAD_WIDTH*0.25, dir:-1 });
    lanes.push({ axis:'x', pos: i*(BLOCK_SIZE+ROAD_WIDTH) + ROAD_WIDTH*0.25, dir: 1 });
    lanes.push({ axis:'x', pos: i*(BLOCK_SIZE+ROAD_WIDTH) - ROAD_WIDTH*0.25, dir:-1 });
  }
  const ROAD_SPAN = (GRID_HALF*2+1)*(BLOCK_SIZE+ROAD_WIDTH)+BLOCK_SIZE;
  for (let i=0; i<24; i++) {
    const lane = lanes[Math.floor(Math.random()*lanes.length)];
    const mesh = new THREE.Mesh(carGeom, carMat.clone());
    mesh.material.color.offsetHSL(Math.random()*0.2, 0, 0);
    mesh.position.y = 0.6;
    if (lane.axis === 'z') {
      mesh.position.x = lane.pos;
      mesh.position.z = (Math.random()*2-1)*ROAD_SPAN/2;
      mesh.rotation.y = lane.dir>0 ? 0 : Math.PI;
    } else {
      mesh.position.z = lane.pos;
      mesh.position.x = (Math.random()*2-1)*ROAD_SPAN/2;
      mesh.rotation.y = lane.dir>0 ? -Math.PI/2 : Math.PI/2;
    }
    mesh.userData = { lane, speed: 8 + Math.random()*10 };
    scene.add(mesh);
    cars.push(mesh);
  }
  function updateCars(dt) {
    for (const c of cars) {
      const { lane, speed } = c.userData;
      if (lane.axis === 'z') {
        c.position.z += lane.dir * speed * dt;
        if (c.position.z > ROAD_SPAN/2) c.position.z = -ROAD_SPAN/2;
        if (c.position.z < -ROAD_SPAN/2) c.position.z = ROAD_SPAN/2;
      } else {
        c.position.x += lane.dir * speed * dt;
        if (c.position.x > ROAD_SPAN/2) c.position.x = -ROAD_SPAN/2;
        if (c.position.x < -ROAD_SPAN/2) c.position.x = ROAD_SPAN/2;
      }
    }
  }

  // --- locomotion (VR sticks + desktop fallback) --------------------
  const keys = new Set();
  addEventListener('keydown', e => keys.add(e.code));
  addEventListener('keyup', e => keys.delete(e.code));
  addEventListener('resize', onResize);
  function onResize() {
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  }

  let yaw = 0;
  const clock = new THREE.Clock();

  function getXRSticks() {
    const session = renderer.xr.getSession();
    let left = { x:0, y:0 }, right = { x:0, y:0 };
    if (!session) return { left, right };
    for (const src of session.inputSources) {
      const gp = src.gamepad;
      if (!gp || gp.axes.length < 2) continue;
      // Many controllers: first 2 axes = primary stick; sometimes 4 axes (stick1 + stick2)
      if (src.handedness === 'left') {
        left.x = gp.axes[0] || 0;
        left.y = gp.axes[1] || 0;
      } else if (src.handedness === 'right') {
        right.x = gp.axes[0] || 0;
        right.y = gp.axes[1] || 0;
      }
    }
    return { left, right };
  }

  function movePlayer(dt) {
    // VR sticks
    const { left, right } = getXRSticks();
    const stickDead = (v) => Math.abs(v) < 0.12 ? 0 : v;
    const lx = stickDead(left.x), ly = stickDead(left.y);
    const rx = stickDead(right.x);

    // Desktop fallback
    const speed = 10; // m/s-ish (yeah we’re zoomin’, baby)
    const turnSpeed = 1.8;
    let movX = lx, movY = ly, turn = rx;
    if (keys.has('KeyW')) movY = -1;
    if (keys.has('KeyS')) movY = 1;
    if (keys.has('KeyA')) movX = -1;
    if (keys.has('KeyD')) movX = 1;
    if (keys.has('KeyQ')) yaw += turnSpeed*dt;
    if (keys.has('KeyE')) yaw -= turnSpeed*dt;
    yaw -= turn * turnSpeed * dt; // right stick X to turn

    // Move relative to camera facing
    const dir = new THREE.Vector3();
    camera.getWorldDirection(dir);
    dir.y = 0; dir.normalize();
    const rightVec = new THREE.Vector3().crossVectors(dir, new THREE.Vector3(0,1,0)).normalize().negate();

    const forward = dir.clone().multiplyScalar(-movY * speed * dt);
    const strafe  = rightVec.clone().multiplyScalar(movX * speed * dt);
    dolly.position.add(forward).add(strafe);

    // Apply yaw around the player
    dolly.rotation.y = yaw;
  }

  // Start player a bit above the ground
  dolly.position.set(0, 0, CITY_EXTENT * 0.6);

  // --- animation loop -----------------------------------------------
  renderer.setAnimationLoop(() => {
    const dt = Math.min(0.033, clock.getDelta());
    movePlayer(dt);
    updateCars(dt);
    rotateMessages(dt);
    renderer.render(scene, camera);
  });

  // lil vibe: sun “moves” slowly (not physically accurate, we’re chill)
  setInterval(() => {
    sun.position.applyAxisAngle(new THREE.Vector3(0,1,0), 0.003);
  }, 30);

  </script>
</body>
</html>
