<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>WebXR Gorilla Push ‚Äî Color Trip (lockup fix + locomotion)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#000; }
    #info {
      position: absolute; left: 12px; top: 12px; color: #e6f7ff; font-family: system-ui, sans-serif;
      padding: 8px 10px; background: rgba(0,0,0,.35); border-radius: 12px; font-size: 14px; user-select:none; z-index:5;
    }
    #tests {
      position: absolute; right: 12px; top: 12px; color: #afffb9; background: rgba(0,0,0,.35);
      padding: 8px 10px; border-radius: 12px; font: 12px/1.2 system-ui, sans-serif; z-index:5;
    }
    #overlay { position: fixed; inset: 0; pointer-events: none; z-index: 9999; display:none; }
    #overlay pre {
      position: absolute; left: 10px; bottom: 10px; right: 10px; max-height: 60%;
      overflow:auto; color:#ffb4b4; background: rgba(30,0,0,.85); padding:12px; border-radius:12px;
      font: 12px/1.4 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <div id="info">
    <b>Gorilla Push ‚Äî Color Trip</b><br/>
    Trigger/Grip to plant ‚Ä¢ Push along surfaces (incl. the ground) to move/jump ‚Ä¢ Reach the rainbow üåà
  </div>
  <div id="tests">Self-tests: (running‚Ä¶)</div>
  <div id="overlay"><pre id="err"></pre></div>

  <script type="module">
    // ===== Error overlay (quiet about XR "already active" noise) =====
    const overlay = document.getElementById('overlay');
    const errBox  = document.getElementById('err');
    function showErr(e){
      const msg  = (e && e.message) ? e.message : String(e);
      const name = (e && e.name) ? e.name : '';
      if (name === 'InvalidStateError' && /already an active, immersive XRSession/i.test(msg)) {
        console.warn('XR busy elsewhere ‚Äî not a crash:', e);
        return;
      }
      overlay.style.display = 'block';
      errBox.textContent += (e && e.stack) ? (e.stack + '\n') : (msg + '\n');
      console.error(e);
    }
    window.addEventListener('error', ev => showErr(ev.error || ev.message));
    window.addEventListener('unhandledrejection', ev => showErr(ev.reason || ev));

    // ===== Imports =====
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { VRButton } from 'https://unpkg.com/three@0.160.0/examples/jsm/webxr/VRButton.js';
    import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

    // ===== Boot =====
    boot().catch(showErr);

    async function boot(){
      const testBox = document.getElementById('tests');

      // Renderer / Scene / Camera
      const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
      renderer.setPixelRatio(devicePixelRatio);
      renderer.setSize(innerWidth, innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.xr.enabled = true;
      // Use 'local' so our own head offset controls height
      renderer.xr.setReferenceSpaceType('local');
      document.body.appendChild(renderer.domElement);
      document.body.appendChild(VRButton.createButton(renderer));

      const scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0xbfe7ff, 20, 80);
      const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.01, 500);
      const dolly = new THREE.Group(); scene.add(dolly); dolly.add(camera);

      scene.add(makeGradientSky(0x85e4ff, 0xfae3ff));
      scene.add(new THREE.HemisphereLight(0xfdf7ff, 0x334455, 0.95));
      const sun = new THREE.DirectionalLight(0xffffff, 0.8); sun.position.set(8,12,6); scene.add(sun);

      // Physics
      const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.81, 0) });
      world.broadphase = new CANNON.SAPBroadphase(world);
      world.allowSleep = true;
      const matDefault = new CANNON.Material('default');
      world.addContactMaterial(new CANNON.ContactMaterial(matDefault, matDefault, { friction:0.5, restitution:0.0 }));

      // Player body
      const playerBody = new CANNON.Body({
        mass: 75, shape: new CANNON.Sphere(0.25),
        position: new CANNON.Vec3(0, 1.4, 0), linearDamping: 0.22, material: matDefault
      });
      world.addBody(playerBody);
      const headOffsetY = 1.32; // eye height above body center

      // Level
      const pushSurfaces = [];
      const updatables = [];
      const pastel = [0xffc1cc,0xffe4a3,0xb9f6a5,0xa6e3ff,0xd0b3ff,0xffc6a5,0xaef1ff,0xfde2ff];

      // Floor is pushable so you can jump
      addBox(60,1,60, 0,-0.5,0, 0x143945, true);

      [
        { s:[3,0.4,3],   p:[0,1,-3],     c: pastel[0] },
        { s:[2,0.4,2],   p:[2.8,2.0,-1.5], c: pastel[1] },
        { s:[1.5,0.4,1.5], p:[4.8,3.0,1.4], c: pastel[2] },
        { s:[2.0,0.4,2.0], p:[7.2,4.2,3.6], c: pastel[3] },
        { s:[1.2,0.4,1.2], p:[9.3,5.6,5.9], c: pastel[4] },
      ].forEach(({s,p,c})=> addBox(s[0],s[1],s[2], p[0],p[1],p[2], c, true));

      const ramp = addBox(3.2,0.3,2.2, 3.6,1.28,-3.8, 0x2c4a7a, true);
      ramp.rotation.set(-Math.PI/10, 0, 0);
      ramp.userData.body.quaternion.setFromEuler(-Math.PI/10, 0, 0);

      const mover = addBox(2.2,0.35,2.2, 11.2,6.8,7.2, 0xffd3a1, true);
      mover.userData.basePos = mover.position.clone();
      updatables.push((dt,t)=>{
        const y = Math.sin(t*0.6)*0.6, x = Math.cos(t*0.3)*0.4;
        mover.position.set(mover.userData.basePos.x + x, mover.userData.basePos.y + y, mover.userData.basePos.z);
        const b = mover.userData.body; b.position.set(mover.position.x, mover.position.y, mover.position.z); b.velocity.set(0,0,0);
      });

      const goal = makeGoalRing(new THREE.Vector3(13.8, 7.4, 9.5)); scene.add(goal.group);

      plantTrees([
        new THREE.Vector3(-6,0,-3), new THREE.Vector3(5,0,-6), new THREE.Vector3(10,0,2),
        new THREE.Vector3(8,0,8), new THREE.Vector3(2,0,5), new THREE.Vector3(-3,0,6), new THREE.Vector3(12,0,12),
      ]);
      [[-6,-3],[5,-6],[10,2],[8,8],[2,5],[-3,6],[12,12]].forEach(([x,z])=>{
        const coll = addBox(0.24,1.1,0.24, x,0.55,z, 0x000000, true); coll.visible = false;
      });

      const sayings = [
        "NO BUGS. ONLY VIBES.","DO NOT PET THE VOID.","GRAVITY IS A SUGGESTION.","MAKE WIDE CHOICES.",
        "ALL YEET, NO FEET.","YOU ARE TEMPORARY; THE FLOOR IS FOREVER.","BEWARE OF LOW-POLY BEARS.",
        "THIS SIGN LEFT INTENTIONALLY WEIRD.","HUG TREES. THEY‚ÄôRE SPIKY AIR FILTERS.","SPEED IS JUST SPICY POSITION.",
        "NARF! AUTHORIZED PERSONNEL ONLY.","PLEASE SCREAM IN PASTEL."
      ];
      const signMeshes = [];
      addSign(new THREE.Vector3(0.2,1.2,-4.2), sayings[0]);
      addSign(new THREE.Vector3(3.2,2.2,-2.0), sayings[2]);
      addSign(new THREE.Vector3(5.0,3.1, 2.2), sayings[3]);
      addSign(new THREE.Vector3(7.4,4.6, 4.2), sayings[4]);
      addSign(new THREE.Vector3(10.2,6.0,6.4), sayings[5]);
      signMeshes.forEach(m=>{
        const b = addBox(0.95,0.65,0.06, m.position.x, m.position.y+0.2, m.position.z-0.02, 0x000000, true);
        b.visible = false;
      });

      const pickups = [];
      for (let i=0;i<6;i++){
        const p = makePickup(); p.position.set(1.5+Math.random()*10, 2.2+Math.random()*4.5, -1.6+Math.random()*9);
        p.userData.phase = Math.random()*Math.PI*2; scene.add(p); pickups.push(p);
      }

      // Controllers / vignette / raycaster
      const controller0 = renderer.xr.getController(0);
      const controller1 = renderer.xr.getController(1);
      dolly.add(controller0); dolly.add(controller1);
      const hands = [ makeHandState(controller0, 0x66ffc2), makeHandState(controller1, 0xffaaff) ];
      const vignette = makeVignette(); camera.add(vignette);
      const raycaster = new THREE.Raycaster();
      const worldUp = new THREE.Vector3(0,1,0);

      // Push/jump tuning
      const PUSH_GAIN = 1.8;
      const MAX_SPEED = 8.5;
      const SURFACE_MAX_DIST = 0.10;
      const NORMAL_DOT_MIN = 0.30;
      const UPWARD_ASSIST = 0.9;
      const BIG_PUSH_COOLDOWN = 0.028;
      let lastBigPushT = 0;

      // Reset + loop
      const clock = new THREE.Clock();
      function resetRun(){
        playerBody.velocity.set(0,0,0);
        playerBody.angularVelocity.set(0,0,0);
        playerBody.position.set(0, 1.4, 0);
        playerBody.quaternion.set(0,0,0,1);
      }
      resetRun();

      addEventListener('resize', ()=>{
        camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
      });

      // End our session if hidden to avoid zombies
      const endIfActive = async ()=> {
        const s = renderer.xr.getSession?.();
        if (s) try { await s.end(); } catch(e){ console.warn('Session end on hide failed (ignored):', e); }
      };
      window.addEventListener('pagehide', endIfActive);
      document.addEventListener('visibilitychange', ()=>{ if (document.hidden) endIfActive(); });

      renderer.setAnimationLoop(()=>{
        const dt = Math.min(clock.getDelta(), 0.033);
        const t  = performance.now()/1000;

        // Physics
        const fixed = 1/90; let acc = dt;
        while (acc > 0) { world.step(fixed, Math.min(acc, fixed), 2); acc -= fixed; }

        // POV follows physics body (head offset up)
        dolly.position.set(playerBody.position.x, playerBody.position.y + headOffsetY, playerBody.position.z);

        // Movers / goal / pickups bling
        updatables.forEach(u=>u(dt,t));
        goal.update(dt, t);
        pickups.forEach(p=>{
          p.rotation.y += dt*1.8;
          p.material.emissiveIntensity = 0.8 + Math.sin(t*2.5 + p.userData.phase)*0.6;
        });
        signMeshes.forEach(m=> m.lookAt(dolly.position.x, m.position.y, dolly.position.z));

        // Comfort vignette
        const speed = playerBody.velocity.length();
        vignette.material.uniforms.uIntensity.value = THREE.MathUtils.clamp((speed - 1.5) / (MAX_SPEED - 1.5), 0, 0.6);

        // Gorilla push
        const now = t;
        for (const h of hands){
          h.ctrl.updateMatrixWorld();
          const pos = new THREE.Vector3().setFromMatrixPosition(h.ctrl.matrixWorld);
          h.velocity.copy(pos).sub(h.lastPos).divideScalar(dt);
          h.lastPos.copy(pos);
          if (!h.isPlanting) continue;

          const forward = new THREE.Vector3(0,0,-1).applyQuaternion(h.ctrl.quaternion);
          const contact = probeContact(raycaster, pos, forward, pushSurfaces, SURFACE_MAX_DIST, NORMAL_DOT_MIN);
          if (!contact) continue;

          const n = contact.normal;
          if (n.dot(worldUp) < -0.98) continue; // ignore ceilings

          const vn = n.clone().multiplyScalar(h.velocity.dot(n));
          const tangential = h.velocity.clone().sub(vn);
          if (tangential.lengthSq() < 1e-4) continue;

          const impulseDir = tangential.clone().normalize().multiplyScalar(-1);
          const mag = tangential.length() * PUSH_GAIN;

          if (now - lastBigPushT > BIG_PUSH_COOLDOWN) {
            applyImpulse(playerBody, impulseDir.multiplyScalar(mag));
            lastBigPushT = now;
            if (n.y > 0.6) applyImpulse(playerBody, new CANNON.Vec3(0, UPWARD_ASSIST, 0));
          }

          // clamp top speed
          const v = playerBody.velocity, len = v.length();
          if (len > MAX_SPEED) v.scale(MAX_SPEED / (len + 1e-6), v);
        }

        // Goal / pickups
        if (dolly.position.distanceTo(goal.group.position) < 1.2) { goal.burst(); setTimeout(()=> resetRun(), 200); }
        for (const p of pickups){
          if (!p.visible) continue;
          if (dolly.position.distanceTo(p.position) < 0.8){ p.visible = false; applyImpulse(playerBody, new CANNON.Vec3(0, 0.8, 0)); }
        }

        renderer.render(scene, camera);
      });

      // ===== Self-tests (unchanged names; added gravity test) =====
      const tests = [];
      const ok = (name, pass, detail='') => tests.push({name, pass, detail});
      ok('THREE loaded', !!THREE.WebGLRenderer);
      ok('CANNON loaded', !!CANNON.World);
      try {
        const w = new CANNON.World(); w.gravity.set(0,-9.81,0);
        const ground = new CANNON.Body({ mass:0, shape:new CANNON.Box(new CANNON.Vec3(1,0.5,1)), position:new CANNON.Vec3(0,-0.5,0) });
        const b = new CANNON.Body({ mass:1, shape:new CANNON.Sphere(0.1), position:new CANNON.Vec3(0,1,0) });
        w.addBody(ground); w.addBody(b); w.step(1/60); w.step(1/60);
        ok('Gravity pulls down', b.position.y < 1);
      } catch (e) { ok('Gravity pulls down', false, String(e)); }
      try {
        const g = new THREE.BoxGeometry(1,1,1), m = new THREE.MeshBasicMaterial({visible:false});
        const box = new THREE.Mesh(g,m); box.position.set(0,0,-2);
        scene.add(box); box.updateMatrixWorld(true);
        const rc = new THREE.Raycaster(); rc.set(new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1)); rc.near = 0.01; rc.far = 10;
        const hits = rc.intersectObject(box, false);
        ok('Raycaster hits box', hits.length > 0, `hits=${hits.length}`);
        scene.remove(box); g.dispose(); m.dispose();
      } catch (e) { ok('Raycaster hits box', false, String(e)); }
      document.getElementById('tests').innerHTML =
        'Self-tests:<br>' + tests.map(t => (t.pass?'‚úÖ':'‚ùå') + ' ' + t.name + (t.detail?` ‚Äî ${t.detail}`:'')).join('<br>');

      // ===== helpers =====
      function addBox(w,h,d, x,y,z, color=0xcccccc, pushable=false){
        const geo = new THREE.BoxGeometry(w,h,d);
        const mat = new THREE.MeshStandardMaterial({ color, roughness:0.85, metalness:0.0 });
        const mesh = new THREE.Mesh(geo, mat); mesh.position.set(x,y,z); scene.add(mesh);
        mesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(geo, 30), new THREE.LineBasicMaterial({ color: 0x001b1f, transparent:true, opacity:0.22 })));
        const body = new CANNON.Body({ mass: 0, shape: new CANNON.Box(new CANNON.Vec3(w/2,h/2,d/2)), position: new CANNON.Vec3(x,y,z), material: matDefault });
        world.addBody(body); mesh.userData.body = body;
        if (pushable) pushSurfaces.push(mesh);
        return mesh;
      }
      function makePickup(){ return new THREE.Mesh(new THREE.IcosahedronGeometry(0.12,0), new THREE.MeshStandardMaterial({ color:0xffffff, emissive:0x55ffff, emissiveIntensity:1.2, roughness:0.4, metalness:0.2 })); }
      function makeGoalRing(pos){
        const group = new THREE.Group(); group.position.copy(pos);
        const tor = new THREE.TorusGeometry(0.8, 0.12, 16, 64);
        const mat = new THREE.ShaderMaterial({
          uniforms: { uTime:{value:0} },
          vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);} `,
          fragmentShader: `
            varying vec2 vUv; uniform float uTime;
            vec3 hsv2rgb(vec3 c){ vec3 p=abs(fract(c.xxx+vec3(1.,2./3.,1./3.))*6.-3.); return c.z*mix(vec3(1.), clamp(p-1.,0.,1.), c.y); }
            void main(){ float u = fract(vUv.x + uTime*0.08); vec3 col = hsv2rgb(vec3(u, 0.9, 1.0)); gl_FragColor = vec4(col, 1.0); }
          `
        });
        const ring = new THREE.Mesh(tor, mat); group.add(ring);
        const sparks = [];
        for (let i=0;i<10;i++){
          const s = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 6), new THREE.MeshStandardMaterial({ color:0xffffff, emissive:0xfff3a0, emissiveIntensity:1.0 }));
          s.position.set(Math.cos(i)*1.1, (i%2?0.2:-0.2), Math.sin(i)*1.1); group.add(s); sparks.push(s);
        }
        return {
          group,
          update(dt,t){ ring.material.uniforms.uTime.value = t; ring.rotation.y += dt*0.5; sparks.forEach((s,i)=> s.scale.setScalar(0.7 + Math.sin(t*3 + i)*0.3)); },
          burst(){ sparks.forEach(s=> s.material.emissiveIntensity = 2.5); setTimeout(()=> sparks.forEach(s=> s.material.emissiveIntensity = 1.0), 200); }
        };
      }
      function plantTrees(positions){
        const trunkGeo = new THREE.CylinderGeometry(0.08, 0.1, 0.8, 8);
        const trunkMat = new THREE.MeshStandardMaterial({ color: 0x7a4a2a, roughness:0.9, metalness:0.0 });
        const trunkInst = new THREE.InstancedMesh(trunkGeo, trunkMat, positions.length);
        const leafGeo = new THREE.ConeGeometry(0.55, 1.1, 8);
        const leafMat = new THREE.MeshStandardMaterial({ color: 0x4dd18a, roughness:0.8, metalness:0.0 });
        const leafInst = new THREE.InstancedMesh(leafGeo, leafMat, positions.length);
        const m = new THREE.Matrix4(); const q = new THREE.Quaternion();
        positions.forEach((p, i)=>{
          const s = 0.9 + Math.random()*0.4;
          m.compose(new THREE.Vector3(p.x, 0.4, p.z), q, new THREE.Vector3(1,1,1)); trunkInst.setMatrixAt(i, m);
          m.compose(new THREE.Vector3(p.x, 1.0, p.z), q, new THREE.Vector3(s,s,s)); leafInst.setMatrixAt(i, m);
        });
        scene.add(trunkInst); scene.add(leafInst);
      }
      function addSign(pos, text){
        const tex = makeSignTexture(text);
        const geo = new THREE.PlaneGeometry(0.9, 0.6);
        const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
        const m = new THREE.Mesh(geo, mat); m.position.copy(pos); m.position.y += 0.2; scene.add(m);
        const post = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.4, 6), new THREE.MeshStandardMaterial({ color: 0x6b6b6b, roughness:0.9 }));
        post.position.set(pos.x, pos.y - 0.1, pos.z); scene.add(post);
      }
      function makeSignTexture(text){
        const c = document.createElement('canvas'); c.width = 512; c.height = 384;
        const ctx = c.getContext('2d');
        const hues = [10,45,120,180,260,300]; const h = hues[Math.floor(Math.random()*hues.length)];
        ctx.fillStyle = `hsl(${h}, 75%, 65%)`; ctx.fillRect(0,0,c.width,c.height);
        ctx.strokeStyle = 'rgba(0,0,0,0.25)'; ctx.lineWidth = 16; ctx.strokeRect(10,10,c.width-20,c.height-20);
        ctx.fillStyle = '#08272d'; ctx.font = '700 42px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        wrapText(ctx, text, 40, 90, c.width-80, 56);
        ctx.fillStyle = 'rgba(255,255,255,0.9)'; ctx.fillRect(c.width-160, 20, 140, 44);
        ctx.fillStyle = '#000'; ctx.font = '700 22px system-ui'; ctx.fillText('WEIRD ZONE', c.width-150, 50);
        const tex = new THREE.CanvasTexture(c); tex.anisotropy = 4; tex.needsUpdate = true; return tex;
      }
      function wrapText(ctx, text, x, y, maxWidth, lineHeight){
        const words = text.split(' '); let line = '';
        for (let n = 0; n < words.length; n++) {
          const test = line + words[n] + ' ';
          if (ctx.measureText(test).width > maxWidth && n > 0) { ctx.fillText(line, x, y); line = words[n] + ' '; y += lineHeight; }
          else line = test;
        }
        ctx.fillText(line, x, y);
      }
      function makeVignette(){
        const g = new THREE.PlaneGeometry(2,2);
        const m = new THREE.ShaderMaterial({
          transparent: true, depthTest: false,
          uniforms: { uIntensity: { value: 0.0 } },
          vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=vec4(position.xy, 0.999, 1.0); }`,
          fragmentShader: `varying vec2 vUv; uniform float uIntensity;
            void main(){ vec2 c = vUv - 0.5; float r = length(c)*1.4; float v = smoothstep(0.3, 1.0, r) * uIntensity; gl_FragColor = vec4(0.0,0.0,0.0, v); }`
        });
        const mesh = new THREE.Mesh(g, m); mesh.renderOrder = 999; return mesh;
      }

      // Include a straight-down ray so ground pushes register cleanly
      function probeContact(raycaster, origin, forward, pushSurfaces, SURFACE_MAX_DIST, NORMAL_DOT_MIN){
        const dirs = [
          forward.clone(),
          forward.clone().add(new THREE.Vector3(0,0.25,0)).normalize(),
          forward.clone().add(new THREE.Vector3(0,-0.25,0)).normalize(),
          new THREE.Vector3(0,-1,0),
          forward.clone().multiplyScalar(-1)
        ];
        for (const d of dirs){
          raycaster.set(origin.clone().addScaledVector(d, 0.06), d);
          raycaster.far = SURFACE_MAX_DIST + 0.12;
          const hits = raycaster.intersectObjects(pushSurfaces, false);
          if (hits.length){
            const hit = hits[0];
            if (hit.face){
              const n = hit.face.normal.clone().transformDirection(hit.object.matrixWorld).normalize();
              if (n.lengthSq() > 0.2 && n.dot(d) < -NORMAL_DOT_MIN) return { point: hit.point, normal: n };
            }
          }
        }
        return null;
      }

      function applyImpulse(body, v){
        const imp = (v.isCANNON) ? v : new CANNON.Vec3(v.x, v.y, v.z);
        body.applyImpulse(imp, body.position);
      }
      function makeHandState(ctrl, color){
        const s = {
          ctrl, isPlanting:false,
          lastPos: new THREE.Vector3(), velocity: new THREE.Vector3(),
          sphere: new THREE.Mesh(new THREE.SphereGeometry(0.05,16,12), new THREE.MeshBasicMaterial({ color, transparent:true, opacity:0.6 }))
        };
        s.sphere.visible = false; ctrl.add(s.sphere);
        ctrl.addEventListener('selectstart', ()=>{ s.isPlanting = true;  s.sphere.visible = true;  });
        ctrl.addEventListener('selectend',   ()=>{ s.isPlanting = false; s.sphere.visible = false; });
        ctrl.addEventListener('squeezestart',()=>{ s.isPlanting = true;  s.sphere.visible = true;  });
        ctrl.addEventListener('squeezeend',  ()=>{ s.isPlanting = false; s.sphere.visible = false; });
        return s;
      }
      function makeGradientSky(top=0x87ceeb, bottom=0xffffff){
        const geo = new THREE.SphereGeometry(200, 32, 16);
        const mat = new THREE.ShaderMaterial({
          side: THREE.BackSide, depthWrite:false,
          uniforms: { top:{value:new THREE.Color(top)}, bottom:{value:new THREE.Color(bottom)} },
          vertexShader: `varying vec3 vPos; void main(){ vPos=position; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
          fragmentShader: `varying vec3 vPos; uniform vec3 top; uniform vec3 bottom;
            void main(){ float h = normalize(vPos).y*0.5+0.5; gl_FragColor = vec4(mix(bottom, top, smoothstep(0.0, 1.0, h)), 1.0); }`
        });
        return new THREE.Mesh(geo, mat);
      }
    }
  </script>
</body>
</html>
